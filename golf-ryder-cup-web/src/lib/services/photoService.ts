/**
 * Photo Gallery Service
 *
 * Manages trip photo gallery with tagging, albums, and "moment of the trip" voting.
 */

import { db } from '@/lib/db';
import type { UUID, ISODateString } from '@/lib/types/models';
import type {
    Photo,
    PhotoAlbum,
    PhotoComment,
    PhotoCategory,
} from '@/lib/types/social';

// ============================================
// PHOTO ALBUMS
// ============================================

/**
 * Create auto-generated albums for a trip
 */
export async function createDefaultAlbums(tripId: UUID): Promise<PhotoAlbum[]> {
    const now = new Date().toISOString();

    const albums: PhotoAlbum[] = [
        {
            id: crypto.randomUUID(),
            tripId,
            name: 'All Photos',
            description: 'All trip photos',
            photoIds: [],
            isAutoGenerated: true,
            createdAt: now,
        },
        {
            id: crypto.randomUUID(),
            tripId,
            name: 'Action Shots',
            description: 'Swings, putts, and golf action',
            photoIds: [],
            isAutoGenerated: true,
            createdAt: now,
        },
        {
            id: crypto.randomUUID(),
            tripId,
            name: 'Group Photos',
            description: 'Team and group shots',
            photoIds: [],
            isAutoGenerated: true,
            createdAt: now,
        },
        {
            id: crypto.randomUUID(),
            tripId,
            name: 'Highlights',
            description: 'Best moments of the trip',
            photoIds: [],
            isAutoGenerated: true,
            createdAt: now,
        },
        {
            id: crypto.randomUUID(),
            tripId,
            name: 'Funny Moments',
            description: 'Blooper reel and funny shots',
            photoIds: [],
            isAutoGenerated: true,
            createdAt: now,
        },
    ];

    await db.photoAlbums.bulkAdd(albums);
    return albums;
}

/**
 * Get all albums for a trip
 */
export async function getTripAlbums(tripId: UUID): Promise<PhotoAlbum[]> {
    return db.photoAlbums.where('tripId').equals(tripId).sortBy('createdAt');
}

/**
 * Create a custom album
 */
export async function createAlbum(
    tripId: UUID,
    name: string,
    description?: string
): Promise<PhotoAlbum> {
    const album: PhotoAlbum = {
        id: crypto.randomUUID(),
        tripId,
        name,
        description,
        photoIds: [],
        isAutoGenerated: false,
        createdAt: new Date().toISOString(),
    };

    await db.photoAlbums.add(album);
    return album;
}

/**
 * Add photo to album
 */
export async function addPhotoToAlbum(albumId: UUID, photoId: UUID): Promise<void> {
    const album = await db.photoAlbums.get(albumId);
    if (!album) return;

    if (!album.photoIds.includes(photoId)) {
        album.photoIds.push(photoId);

        // Set cover photo if this is the first photo
        if (!album.coverPhotoId) {
            album.coverPhotoId = photoId;
        }

        await db.photoAlbums.update(albumId, {
            photoIds: album.photoIds,
            coverPhotoId: album.coverPhotoId,
        });
    }
}

/**
 * Remove photo from album
 */
export async function removePhotoFromAlbum(albumId: UUID, photoId: UUID): Promise<void> {
    const album = await db.photoAlbums.get(albumId);
    if (!album) return;

    album.photoIds = album.photoIds.filter(id => id !== photoId);

    // Update cover photo if removed
    if (album.coverPhotoId === photoId) {
        album.coverPhotoId = album.photoIds[0];
    }

    await db.photoAlbums.update(albumId, {
        photoIds: album.photoIds,
        coverPhotoId: album.coverPhotoId,
    });
}

/**
 * Set album cover photo
 */
export async function setAlbumCover(albumId: UUID, photoId: UUID): Promise<void> {
    await db.photoAlbums.update(albumId, { coverPhotoId: photoId });
}

// ============================================
// PHOTOS
// ============================================

/**
 * Upload a photo
 */
export async function uploadPhoto(
    tripId: UUID,
    uploaderId: UUID,
    uploaderName: string,
    url: string,
    options?: {
        thumbnailUrl?: string;
        caption?: string;
        category?: PhotoCategory;
        taggedPlayerIds?: UUID[];
        matchId?: UUID;
        sessionId?: UUID;
        holeNumber?: number;
        location?: string;
        takenAt?: ISODateString;
        albumId?: UUID;
    }
): Promise<Photo> {
    const now = new Date().toISOString();

    const photo: Photo = {
        id: crypto.randomUUID(),
        tripId,
        albumId: options?.albumId,
        uploaderId,
        uploaderName,
        url,
        thumbnailUrl: options?.thumbnailUrl,
        caption: options?.caption,
        category: options?.category || 'other',
        taggedPlayerIds: options?.taggedPlayerIds || [],
        matchId: options?.matchId,
        sessionId: options?.sessionId,
        holeNumber: options?.holeNumber,
        location: options?.location,
        takenAt: options?.takenAt,
        likes: [],
        comments: [],
        isMomentOfTrip: false,
        momentVotes: [],
        uploadedAt: now,
        createdAt: now,
    };

    await db.photos.add(photo);

    // Auto-categorize into albums
    await autoCategorizePhoto(photo);

    return photo;
}

/**
 * Auto-categorize photo into relevant albums
 */
async function autoCategorizePhoto(photo: Photo): Promise<void> {
    const albums = await getTripAlbums(photo.tripId);

    // Add to "All Photos"
    const allPhotos = albums.find(a => a.name === 'All Photos');
    if (allPhotos) {
        await addPhotoToAlbum(allPhotos.id, photo.id);
    }

    // Category-based albums
    switch (photo.category) {
        case 'action':
            const actionAlbum = albums.find(a => a.name === 'Action Shots');
            if (actionAlbum) await addPhotoToAlbum(actionAlbum.id, photo.id);
            break;
        case 'group':
            const groupAlbum = albums.find(a => a.name === 'Group Photos');
            if (groupAlbum) await addPhotoToAlbum(groupAlbum.id, photo.id);
            break;
        case 'funny':
            const funnyAlbum = albums.find(a => a.name === 'Funny Moments');
            if (funnyAlbum) await addPhotoToAlbum(funnyAlbum.id, photo.id);
            break;
        case 'celebration':
            const highlightsAlbum = albums.find(a => a.name === 'Highlights');
            if (highlightsAlbum) await addPhotoToAlbum(highlightsAlbum.id, photo.id);
            break;
    }
}

/**
 * Get photos for a trip
 */
export async function getTripPhotos(
    tripId: UUID,
    options?: {
        albumId?: UUID;
        category?: PhotoCategory;
        playerId?: UUID; // Tagged player
        limit?: number;
    }
): Promise<Photo[]> {
    let photos: Photo[];

    if (options?.albumId) {
        photos = await db.photos
            .where('[albumId+uploadedAt]')
            .between([options.albumId, ''], [options.albumId, '\uffff'])
            .reverse()
            .toArray();
    } else {
        photos = await db.photos
            .where('tripId')
            .equals(tripId)
            .reverse()
            .sortBy('uploadedAt');
    }

    // Apply filters
    if (options?.category) {
        photos = photos.filter(p => p.category === options.category);
    }

    if (options?.playerId) {
        photos = photos.filter(p =>
            p.taggedPlayerIds.includes(options.playerId!) ||
            p.uploaderId === options.playerId
        );
    }

    if (options?.limit) {
        photos = photos.slice(0, options.limit);
    }

    return photos;
}

/**
 * Get a single photo
 */
export async function getPhoto(photoId: UUID): Promise<Photo | undefined> {
    return db.photos.get(photoId);
}

/**
 * Update photo details
 */
export async function updatePhoto(
    photoId: UUID,
    updates: {
        caption?: string;
        category?: PhotoCategory;
        taggedPlayerIds?: UUID[];
        holeNumber?: number;
    }
): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    await db.photos.update(photoId, updates);
    return { ...photo, ...updates };
}

/**
 * Tag players in a photo
 */
export async function tagPlayers(photoId: UUID, playerIds: UUID[]): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    const uniqueIds = [...new Set([...photo.taggedPlayerIds, ...playerIds])];
    await db.photos.update(photoId, { taggedPlayerIds: uniqueIds });

    return { ...photo, taggedPlayerIds: uniqueIds };
}

/**
 * Remove player tag from photo
 */
export async function untagPlayer(photoId: UUID, playerId: UUID): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    const newTags = photo.taggedPlayerIds.filter(id => id !== playerId);
    await db.photos.update(photoId, { taggedPlayerIds: newTags });

    return { ...photo, taggedPlayerIds: newTags };
}

/**
 * Like a photo
 */
export async function likePhoto(photoId: UUID, playerId: UUID): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    if (!photo.likes.includes(playerId)) {
        photo.likes.push(playerId);
        await db.photos.update(photoId, { likes: photo.likes });
    }

    return photo;
}

/**
 * Unlike a photo
 */
export async function unlikePhoto(photoId: UUID, playerId: UUID): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    photo.likes = photo.likes.filter(id => id !== playerId);
    await db.photos.update(photoId, { likes: photo.likes });

    return photo;
}

/**
 * Add a comment to a photo
 */
export async function addPhotoComment(
    photoId: UUID,
    authorId: UUID,
    authorName: string,
    content: string
): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    const comment: PhotoComment = {
        id: crypto.randomUUID(),
        authorId,
        authorName,
        content,
        createdAt: new Date().toISOString(),
    };

    photo.comments.push(comment);
    await db.photos.update(photoId, { comments: photo.comments });

    return photo;
}

/**
 * Delete a photo comment
 */
export async function deletePhotoComment(photoId: UUID, commentId: UUID): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    photo.comments = photo.comments.filter(c => c.id !== commentId);
    await db.photos.update(photoId, { comments: photo.comments });

    return photo;
}

/**
 * Delete a photo
 */
export async function deletePhoto(photoId: UUID): Promise<void> {
    // Remove from all albums
    const photo = await db.photos.get(photoId);
    if (!photo) return;

    const albums = await getTripAlbums(photo.tripId);
    for (const album of albums) {
        if (album.photoIds.includes(photoId)) {
            await removePhotoFromAlbum(album.id, photoId);
        }
    }

    await db.photos.delete(photoId);
}

// ============================================
// MOMENT OF THE TRIP VOTING
// ============================================

/**
 * Nominate a photo for "Moment of the Trip"
 */
export async function nominateMomentOfTrip(photoId: UUID): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    await db.photos.update(photoId, { isMomentOfTrip: true });
    return { ...photo, isMomentOfTrip: true };
}

/**
 * Remove nomination for "Moment of the Trip"
 */
export async function removeNomination(photoId: UUID): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    await db.photos.update(photoId, { isMomentOfTrip: false, momentVotes: [] });
    return { ...photo, isMomentOfTrip: false, momentVotes: [] };
}

/**
 * Vote for a "Moment of the Trip" candidate
 */
export async function voteForMoment(photoId: UUID, playerId: UUID): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo || !photo.isMomentOfTrip) return undefined;

    if (!photo.momentVotes.includes(playerId)) {
        photo.momentVotes.push(playerId);
        await db.photos.update(photoId, { momentVotes: photo.momentVotes });
    }

    return photo;
}

/**
 * Remove vote for "Moment of the Trip"
 */
export async function removeVoteForMoment(photoId: UUID, playerId: UUID): Promise<Photo | undefined> {
    const photo = await db.photos.get(photoId);
    if (!photo) return undefined;

    photo.momentVotes = photo.momentVotes.filter(id => id !== playerId);
    await db.photos.update(photoId, { momentVotes: photo.momentVotes });

    return photo;
}

/**
 * Get "Moment of the Trip" nominees with vote counts
 */
export async function getMomentOfTripCandidates(tripId: UUID): Promise<Photo[]> {
    const photos = await db.photos.where('tripId').equals(tripId).toArray();
    return photos
        .filter(p => p.isMomentOfTrip)
        .sort((a, b) => b.momentVotes.length - a.momentVotes.length);
}

/**
 * Get the winning "Moment of the Trip" photo
 */
export async function getMomentOfTripWinner(tripId: UUID): Promise<Photo | undefined> {
    const candidates = await getMomentOfTripCandidates(tripId);
    return candidates.length > 0 ? candidates[0] : undefined;
}

// ============================================
// PHOTO STATS
// ============================================

/**
 * Get photo statistics for a trip
 */
export async function getPhotoStats(tripId: UUID): Promise<{
    totalPhotos: number;
    photosByCategory: Record<PhotoCategory, number>;
    topContributors: { playerId: UUID; count: number }[];
    mostLiked: Photo[];
    mostCommented: Photo[];
}> {
    const photos = await db.photos.where('tripId').equals(tripId).toArray();

    // Count by category
    const photosByCategory: Record<PhotoCategory, number> = {
        action: 0,
        group: 0,
        scenic: 0,
        celebration: 0,
        funny: 0,
        other: 0,
    };

    for (const photo of photos) {
        photosByCategory[photo.category]++;
    }

    // Top contributors
    const contributorCounts = new Map<UUID, number>();
    for (const photo of photos) {
        const count = contributorCounts.get(photo.uploaderId) || 0;
        contributorCounts.set(photo.uploaderId, count + 1);
    }

    const topContributors = Array.from(contributorCounts.entries())
        .map(([playerId, count]) => ({ playerId, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 5);

    // Most liked
    const mostLiked = [...photos]
        .sort((a, b) => b.likes.length - a.likes.length)
        .slice(0, 5);

    // Most commented
    const mostCommented = [...photos]
        .sort((a, b) => b.comments.length - a.comments.length)
        .slice(0, 5);

    return {
        totalPhotos: photos.length,
        photosByCategory,
        topContributors,
        mostLiked,
        mostCommented,
    };
}

/**
 * Get photos where a player is tagged
 */
export async function getPhotosOfPlayer(tripId: UUID, playerId: UUID): Promise<Photo[]> {
    const photos = await db.photos.where('tripId').equals(tripId).toArray();
    return photos.filter(p => p.taggedPlayerIds.includes(playerId));
}
